<?xml version="1.0"?>
<!--
  UNUSED stuff
                    for ZORK 1
-->
<library>

  <function name="SetUpCustomVerbsLists"><![CDATA[
    foreach (o, AllObjects()) {
      o.displayverbs = ListExclude(o.displayverbs,Split("cloningdisplayverbs"))
      o.inventoryverbs = ListExclude(o.inventoryverbs,Split("cloninginventoryverbs"))
      if (FSET_P(o,"TAKEBIT")) {
        list add (o.displayverbs, "Take")
      }
      if (not FSET_P(o,"SURFACEBIT") and (FSET_P(o,"CONTBIT") or FSET_P(o,"DOORBIT"))) {
        if (not FSET_P(o,"OPENBIT")) {
          list add (o.displayverbs, "Open")
          list add (o.inventoryverbs, "Open")
        }
        else {
          list add (o.displayverbs, "Close")
          list add (o.inventoryverbs, "Close")
        }
        o.changedOPENBIT => {
          this.isopen = this.OPENBIT
          if (FSET_P(this,"OPENBIT")) {
            PUT (this.displayverbs, IndexOf (this.displayverbs, "Open"), "Close")
            PUT (this.inventoryverbs, IndexOf (this.inventoryverbs, "Open"), "Close")
          }
          else {
            PUT (this.displayverbs, IndexOf (this.displayverbs, "Close"), "Open")
            PUT (this.inventoryverbs, IndexOf (this.inventoryverbs, "Close"), "Open")
          }
        }
      }
      if (FSET_P(o,"READBIT")) {
        list add (o.displayverbs, "Read")
        list add (o.inventoryverbs, "Read")
      }
      if (FSET_P(o,"LIGHTBIT") or FSET_P(o,"FLAMEBIT")) {
        if (FSET_P(o,"FLAMEBIT")) {
          if (not FSET_P(o,"ONBIT")) {
            list add (o.displayverbs, "Light")
            list add (o.inventoryverbs, "Light")
          }
          else {
            list add (o.displayverbs, "Douse")
            list add (o.inventoryverbs, "Douse")
            o.listalias = o.alias + " (providing light)"
          }
          o.changedONBIT => {
            if (FSET_P(this,"ONBIT")) {
              PUT (this.displayverbs, IndexOf (this.displayverbs, "Light"), "Douse")
              PUT (this.inventoryverbs, IndexOf (this.inventoryverbs, "Light"), "Douse")
              this.listalias = this.alias + " (providing light)"
            }
            else {
              PUT (this.displayverbs, IndexOf (this.displayverbs, "Douse"), "Light")
              PUT (this.inventoryverbs, IndexOf (this.inventoryverbs, "Douse"), "Light")
              this.listalias = this.alias
            }
          }
        }
        else {
          if (not FSET_P(o,"ONBIT")) {
            list add (o.displayverbs, "Turn on")
            list add (o.inventoryverbs, "Turn on")
          }
          else {
            list add (o.displayverbs, "Turn off")
            list add (o.inventoryverbs, "Turn off")
            o.listalias = o.alias + " (providing light)"
          }
          o.changedONBIT => {
            if (FSET_P(this,"ONBIT")) {
              PUT (this.displayverbs, IndexOf (this.displayverbs, "Turn on"), "Turn off")
              PUT (this.inventoryverbs, IndexOf (this.inventoryverbs, "Turn on"), "Turn off")
              this.listalias = this.alias + " (providing light)"
            }
            else {
              PUT (this.displayverbs, IndexOf (this.displayverbs, "Turn off"), "Turn on")
              PUT (this.inventoryverbs, IndexOf (this.inventoryverbs, "Turn off"), "Turn on")
              this.listalias = this.alias
            }
          }
        }
      }
    }
  ]]></function>

  <function name="DoLoadingScreen"><![CDATA[
    // JS.eval ("$('#status,#gameContent,#qv-status').hide(); $('#gameBorder').prepend('<div id=\"loadingstory\"><br/><br/><br/><br/><center>ZORK I: THE GREAT UNDERGROUND EMPIRE<br/>by Marc Blank and Dave Lebling<br/>Original Copyright (c) 1981, 1982, 1983, 1984, 1985, 1986 Infocom, Inc. All rights reserved.<br/>ZORK is a registered trademark of Infocom, Inc.<br/>MIT License - Copyright (c) 2025 Microsoft</center><br/><br/>Quest Text Adventure Engine, version 5.9<br/>Copyright (c) 2025 Alex Warren, Andy Joel and contributors<br/><br/>Story loading. Please wait. . .<br/>312 pages allocated.</div>');")
    // SetTimeout (6) {
      // JS.eval ("$('#loadingstory').remove(); $('#gameContent').show(); $('#status').show(); $('#qv-status').show();")
      // }
    // SetTimeout (2) {
      // JS.updateLocation (CapFirst(game.pov.parent.alias) + "<span class=\"score-moves\" style=\"float:right;margin-right:1%;\">Score: " + GLOBAL.SCORE + "&emsp;Moves: " + GLOBAL.MOVES + "&emsp;</span>")
      // }
  ]]></function>

  <function name="FAKE_PARSE" parameters="str">
    firster = StringListItem(str,0)
    n = GET_PART_OF_SPEECH (firster)
    if (not adjective_recognized and not object_recognized) {
      if (not verb_recognized) {
        msg ("I don't know the word \"" + firster + "\".")
      }
    }
    else if (not verb_recognized) {
      msg ("I don't know how to '" + firster + "'.")
    }
    else {
      msg (Template("UnrecognisedCommand"))
    }
  </function>

  <function name="ORPHAN" parameters="prsa, var, object1">
    GLOBAL.O_FLAG = true
    GLOBAL.O_TABLE = NewDictionary()
    dictionary add (GLOBAL.O_TABLE, "PRSA", prsa)
    dictionary add (GLOBAL.O_TABLE, "ORPHANED", var)
    if (not object1 = NOTHING) {
      dictionary add (GLOBAL.O_TABLE, "object1", object1)
    }
  </function>

  <function name="UnresolvedCommand" parameters="objectname, varname"><![CDATA[
    // TO DO: Update names below, we don't need these two variables
    unresolvedobject = objectname
    unresolvedkey = varname
    if (HasString(game.pov.currentcommandpattern, "unresolved")) {
      if (ListCount(game.pov.currentcommandvarlist) > 1) {
        msg (game.pov.currentcommandpattern.unresolved + " (" + unresolvedobject + ")")
      }
      else {
        msg (game.pov.currentcommandpattern.unresolved)
      }
    }
    else if (HasScript(game.pov.currentcommandpattern, "unresolved")) {
      do (game.pov.currentcommandpattern, "unresolved", QuickParams("object", unresolvedobject, "key", unresolvedkey))
    }
    else {
      // msg ("game.pov.currentcommandvarlist: " + game.pov.currentcommandvarlist)
      // if (game.pov.currentcommandpattern = V_WALK and unresolvedobject = "around") {
        // msg ("Walk around what?")
        // ORPHAN (V_WALK_AROUND, "object1", NOTHING)
        // return (1)
        // }
      if (ListCount(game.pov.currentcommandvarlist) > 1) {
        msg (Template("UnresolvedObject") + " (" + unresolvedobject + ")")
      }
      else {
        msg (Template("UnresolvedObject"))
      }
    }
    game.unresolvedcommand = game.pov.currentcommandpattern
    game.unresolvedcommandvarlist = game.pov.currentcommandvarlist
    game.unresolvedcommandkey = unresolvedkey
  ]]></function>

  <function name="HandleSingleCommand" parameters="command"><![CDATA[
    if (GetBoolean(GLOBAL,"O_FLAG")) {
      GLOBAL.O_FLAG = false
      orphaned = DictionaryItem(GLOBAL.O_TABLE,"ORPHANED")
      o_cmd = DictionaryItem (GLOBAL.O_TABLE, "PRSA")
      dictionary remove (GLOBAL.O_TABLE, "PRSA")
      if (StartsWith(orphaned, "text")) {
        dictionary add (GLOBAL.O_TABLE, orphaned, command)
        PERFORM_COMMAND (o_cmd, "script", GLOBAL.O_TABLE)
        // TODO add this to command history properly
        GLOBAL.O_TABLE = null
        return (1)
      }
      else {
        res = FindObjectFromString(command)
        if (DictionaryContains(res, "onlymatch")) {
          o_obj = DictionaryItem(res,"onlymatch")
        }
        else {
          o_obj = NOTHING
          // TODO which do you mean?
        }
        if (not o_obj = NOTHING) {
          dictionary add (GLOBAL.O_TABLE, orphaned, o_obj)
          PERFORM_COMMAND (o_cmd, "script", GLOBAL.O_TABLE)
          // TODO add this to command history properly
          GLOBAL.O_TABLE = null
          return (1)
        }
      }
      GLOBAL.O_TABLE = null
    }
    if (LCase(command) = LCase(Template("Again1")) or LCase(command) = LCase(Template("Again2"))) {
      // First handle AGAIN
      if (not game.pov.currentcommand = null) {
        HandleSingleCommand (game.pov.currentcommand)
      }
      else {
        msg ("There is nothing to repeat.")
      }
    }
    else {
      // Check through all commands for any that match
      candidates = NewObjectList()
      foreach (cmd, ScopeCommands()) {
        if (IsRegexMatch(cmd.pattern, command, cmd.name)) {
          list add (candidates, cmd)
        }
      }
      maxstrength = -1
      thiscommand = null
      // Pick the best match
      foreach (candidate, candidates) {
        strength = GetMatchStrength(candidate.pattern, command, candidate.name)
        // favour commands defined later, so an author can override a library command...
        if (strength >= maxstrength) {
          // ... except if the command defined later (candidate) has no parent, and the current best
          // match (thiscommand) does have a parent. We want to favour any commands defined in rooms
          // over global candidates.
          skip = false
          if (thiscommand <> null) {
            if (thiscommand.parent <> null and candidate.parent = null) {
              skip = true
            }
          }
          if (not skip) {
            thiscommand = candidate
            maxstrength = strength
          }
        }
      }
      if (thiscommand = null) {
        if (HasScript(game, "unresolvedcommandhandler")) {
          params = NewDictionary()
          dictionary add (params, "command", command)
          do (game, "unresolvedcommandhandler", params)
        }
        else {
          msg (Template("UnrecognisedCommand"))
        }
        HandleNextCommandQueueItem
      }
      else {
        varlist = Populate(thiscommand.pattern, command, thiscommand.name)
        HandleSingleCommandPattern (command, thiscommand, varlist)
      }
    }
  ]]></function>

</library>