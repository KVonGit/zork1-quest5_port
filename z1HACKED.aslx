<?xml version="1.0"?>
<!--
  HACKED Quest stuff
                    for ZORK 1
-->
<library>

  <function name="FixContinueLink">
    JS.eval ("$('#endWaitDiv').insertBefore($('#txtCommandDiv'))")
  </function>

  <function name="RemoveTypeHereLabel">
    JS.setInterfaceString ("TypeHereLabel", "")
  </function>

  <template name="UnresolvedLocation">{=WriteVerb(game.pov, "can't")} go that way.</template>
  
  <dynamictemplate name="LookAtDarkness">"It is pitch black.{if not GLOBAL.SPRAYED: You are likely to be eaten by a grue.}"</dynamictemplate>

  <type name="defaultobject">
    <visible />
    <displayverbs type="stringlist">
      <value>Examine</value>
    </displayverbs>
    <inventoryverbs type="stringlist">
      <value>Examine</value>
      <value>Drop</value>
    </inventoryverbs>
    <take type="boolean">false</take>
    <use type="boolean">false</use>
    <givesingle type="boolean">false</givesingle>
    <drop />
    <gender>it</gender>
    <article>it</article>
    <possessive>its</possessive>
    <wornmodifier>worn</wornmodifier>
    <isopen type="boolean">false</isopen>
    <open type="boolean">false</open>
    <close type="boolean">false</close>
    <container type="boolean">false</container>
    <descprefix>{=WriteVerb(game.pov, "be")} in</descprefix>
    <objectslistprefix>{=WriteVerb(game.pov, "can")} see</objectslistprefix>
    <exitslistprefix>{=WriteVerb(game.pov, "can")} go</exitslistprefix>
    <contentsprefix>containing</contentsprefix>
    <description type="string"></description>
    <attr name="implementation_notes" type="string"></attr>
    <scenery type="boolean">false</scenery>
    <hidechildren type="boolean">false</hidechildren>
    <listchildren type="boolean">false</listchildren>
    <usedefaultprefix />
    <volume type="int">0</volume>
    <price type="int">0</price>
    <dark type="boolean">false</dark>
    <lightstrength type="string"></lightstrength>
    <darklevel type="boolean">false</darklevel>
    <attr name="grid_width" type="int">1</attr>
    <attr name="grid_length" type="int">1</attr>
    <attr name="grid_fill">White</attr>
    <attr name="grid_border">Black</attr>
    <attr name="grid_borderwidth" type="int">1</attr>
    <attr name="grid_bordersides" type="int">15</attr>
    <attr name="grid_render" type="boolean">false</attr>
    <attr name="grid_label" type="string"></attr>
    <attr name="grid_label_colour">Black</attr>
    <grid_parent_offset_auto />
    <attr name="grid_parent_offset_x" type="int">0</attr>
    <attr name="grid_parent_offset_y" type="int">0</attr>
    <alias>defaultobject</alias>
    <attr name="pov_look">Looking good.</attr>
    <attr name="pov_gender">you</attr>
    <attr name="pov_article">yourself</attr>
    <attr name="pov_possessive">your</attr>
    <attr name="feature_usegive" type="boolean">false</attr>
    <attr name="feature_container" type="boolean">false</attr>
    <attr name="feature_switchable" type="boolean">false</attr>
    <attr name="feature_edible" type="boolean">false</attr>
    <attr name="feature_player" type="boolean">false</attr>
    <attr name="feature_lightdark" type="boolean">false</attr>
    <visited type="boolean">false</visited>
    <hasbeenmoved type="boolean">false</hasbeenmoved>
    <timesexamined type="int">0</timesexamined>
    <attr name="not_all" type="boolean">false</attr>
    <STRENGTH type="int">0</STRENGTH>
    <pov_alt type="stringlist" />
    <changedparent type="script">
      if (game.pov = this) {
        GLOBAL.HERE = this.parent
        if (IsDefined("oldvalue")) {
          OnEnterRoom (oldvalue)
        }
        else {
          OnEnterRoom (null)
        }
        if (game.gridmap) {
          MergePOVCoordinates
        }
      }
      this.hasbeenmoved = true
    </changedparent>
    <changedisopen type="script">
      if (this.isopen and HasScript(this, "onopen")) {
        do (this, "onopen")
      }
      if (not this.isopen and HasScript(this, "onclose")) {
        do (this, "onclose")
      }
    </changedisopen>
    <changedlocked type="script">
      if (this.locked and HasScript(this, "onlock")) {
        do (this, "onlock")
      }
      if (not this.locked and HasScript(this, "onunlock")) {
        do (this, "onunlock")
      }
    </changedlocked>
    <changedswitchedon type="script">
      if (this.switchedon and HasScript(this, "onswitchon")) {
        do (this, "onswitchon")
      }
      if (not this.switchedon and HasScript(this, "onswitchoff")) {
        do (this, "onswitchoff")
      }
    </changedswitchedon>
  </type>

  <function name="OnEnterRoom" parameters="oldRoom"><![CDATA[
    game.displayroomdescriptiononstart = false
    if (IsDefined("oldRoom")) {
      if (oldRoom <> null) {
        if (game.clearscreenonroomenter) {
          ClearScreen
          if (not game.currentexitmessage = null) {
            msg (game.currentexitmessage)
            game.currentexitmessage = null
          }
        }
        if (HasScript(oldRoom, "onexit")) {
          do (oldRoom, "onexit")
        }
      }
    }
    on ready {
      if ((not GetBoolean(game.pov.parent, "visited")) and HasScript(game.pov.parent, "beforefirstenter")) {
        do (game.pov.parent, "beforefirstenter")
      }
      on ready {
        if (HasScript(game.pov.parent, "beforeenter")) {
          do (game.pov.parent, "beforeenter")
        }
        on ready {
          if (game.gridmap) {
            Grid_CalculateMapCoordinates (game.pov.parent, game.pov)
            Grid_DrawPlayerInRoom (game.pov.parent)
          }
          if (IsDefined("oldRoom")) {
            if (oldRoom <> null and game.changeroom_newline and not game.command_newline) {
              msg ("")
            }
          }
          UpdateLocationString (CapFirst (GetDisplayAlias (game.pov.parent)))
          roomFrameExists = false
          if (HasString(game.pov.parent, "picture")) {
            if (LengthOf(game.pov.parent.picture) > 0) {
              roomFrameExists = true
              SetFramePicture (game.pov.parent.picture)
            }
          }
          if (game.clearframe and not roomFrameExists) {
            ClearFramePicture
          }
          if (game.showdescriptiononenter) {
            ShowRoomDescription
          }
          if (HasScript( game, "roomenter")) {
            do (game, "roomenter")
          }
          on ready {
            if ((not GetBoolean(game.pov.parent, "visited")) and HasScript(game.pov.parent, "firstenter")) {
              do (game.pov.parent, "firstenter")
            }
            on ready {
              if (HasScript(game.pov.parent, "enter")) {
                do (game.pov.parent, "enter")
              }
            }
            set (game.pov.parent, "visited", true)
          }
        }
      }
    }
  ]]></function>

  <function name="GetScoping" parameters="scopestring, variable" type="string"><![CDATA[
    lst = Split(scopestring, "|")
    if (ListCount(lst) = 1) {
      if (Instr(scopestring,"=") > 0) {
        sp = Split(scopestring,"=")
        scope = sp[1]
        return (scope)
      }
      return (scopestring)
    }
    foreach (s, lst) {
      if (Instr(s,"=") > 0) {
        sp = Split(s,"=")
        scope = sp[1]
        return (scope)
      }
    }
    return ("all")
  ]]></function>

  <function name="GetScope" parameters="variable, value, objtype" type="objectlist"><![CDATA[
    items = NewObjectList()
    if (HasString(game.pov.currentcommandpattern, "scope")) {
      scoping = GetScoping(game.pov.currentcommandpattern.scope, variable)
      foreach (partscope, Split(scoping, ";")) {
        switch (partscope) {
          case ("inventory","INVENTORY","HAVE") {
            items = ListCombine(items, ScopeInventory())
          }
          case ("notheld","room","NOTHELD") {
            items = ListCombine(items, ScopeReachableNotHeld()) - game.pov
          }
          case ("all") {
            items = ListCombine(items, ScopeVisible()) - game.pov
          }
          case ("container") {
            items = ListCombine(items, FilterByType(ScopeVisible(), "container_base"))
          }
          case ("contents") {
            foreach (cont, FilterByAttribute(FilterByType(ScopeVisible(), "container_base"),"OPENBIT")) {
              items = ListCombine(items, GetAllChildObjects(cont))
            }
          }
          case ("CARRIED") {
            foreach (cont, FilterByAttribute(FilterByType(ScopeInventory(), "container_base"),"OPENBIT")) {
              items = ListCombine(items, GetAllChildObjects(cont))
            }
          }
          case ("HELD") {
            items = ListCombine(items,GetDirectChildren(game.pov))
          }
          case ("IN_ROOM") {
            foreach (cont, FilterByType(ScopeVisibleNotHeld(), "container_base")) {
              if (FSET_P(cont,"OPENBIT")) {
                items = ListCombine(items, ScopeVisibleForRoom(cont))
              }
            }
          }
          case ("ON_GROUND") {
            items = ListCombine(items, FilterByAttribute(ScopeVisibleForRoom(game.pov.parent) - game.pov,"parent",game.pov.parent))
          }
          case ("world") {
            items = ListCombine(items, AllObjects()) - game.pov
          }
          case ("none") {
          }
          default {
            // The command's "scope" can be the name of an object, or an attribute of the player's parent
            if (TypeOf(partscope) = "object" and not partscope = null) {
              list add (items, partscope)
            }
            obj = GetObject(partscope)
            if (not obj = null) {
              items = ListCombine(items, GetAllChildObjects(obj))
            }
            if (HasObject(game.pov.parent, partscope)) {
              obj = GetAttribute(game.pov.parent, partscope)
              items = ListCombine(items, GetAllChildObjects(obj))
            }
            else if (HasAttribute(game.pov.parent, partscope)) {
              attr = GetAttribute(game.pov.parent, partscope)
              if (TypeOf(attr) = "objectlist") {
                items = ListCombine (items, attr)
              }
            }
            else if (HasAttribute(game.pov, partscope)) {
              attr = GetAttribute(game.pov, partscope)
              if (TypeOf(attr) = "objectlist") {
                items = ListCombine (items, attr)
              }
            }
          }
        }
      }
    }
    else if (objtype = "object") {
      items = ScopeVisible()
    }
    else if (objtype = "exit") {
      items = ScopeExits()
    }
    else {
      // Should never get here!
      // CHANGE: Should still never get here, but we don't return null.
      // If we get here somehow, trust user's scripts to define scope.
    }
    items = ObjectListCompact(items) - game.pov
    // CHANGE: Run the script 'changecommandscope' (if it exists) for the game object, the player's room and
    // containing rooms, and the current command. This allows the user to change command scope on a per-location
    // or per-command basis
    // This script gets an "items" list parameter, like `scopebackdrop` script does; but also has parameters
    // 'command', 'variable', and 'objtype', so the user can adjust their script to give different item lists
    // for different commands, or different variables within a command.
    objectswithscripts = NewObjectList()
    if (HasScript(game.pov.currentcommandpattern, "changecommandscope")) {
      list add (objectswithscripts, game.pov.currentcommandpattern)
    }
    room = game.pov
    while (not room = null) {
      if (HasScript(room, "changecommandscope")) {
        list add (objectswithscripts, room)
      }
      room = room.parent
    }
    if (HasScript(game, "changecommandscope")) {
      list add (objectswithscripts, game)
    }
    if (ListCount(objectswithscripts) > 0) {
      params = NewDictionary()
      dictionary add (params, "items", items)
      dictionary add (params, "command", game.pov.currentcommandpattern)
      dictionary add (params, "variable", variable)
      dictionary add (params, "objtype", objtype)
      dictionary add (params, "matched", game.pov.currentcommandresolvedelements)
      foreach (o, objectswithscripts) {
        do (o, "changecommandscope", params)
      }
      items = ObjectListCompact(items)
    }
    return (items)
  ]]></function>

  <function name="ResolveNextName"><![CDATA[
    resolvedall = false
    queuetype = TypeOf(game.pov, "currentcommandvarlistqueue")
    if (queuetype = "stringlist") {
      queuelength = ListCount(game.pov.currentcommandvarlistqueue)
      if (queuelength > 0) {
        // Pop next variable off the queue
        var = StringListItem(game.pov.currentcommandvarlistqueue, 0)
        if (queuelength = 1) {
          game.pov.currentcommandvarlistqueue = null
        }
        else {
          newqueue = NewStringList()
          for (i, 1, queuelength - 1) {
            list add (newqueue, StringListItem(game.pov.currentcommandvarlistqueue, i))
          }
          game.pov.currentcommandvarlistqueue = newqueue
        }
        // Resolve variable
        value = StringDictionaryItem(game.pov.currentcommandvarlist, var)
        if (value <> "") {
          result = null
          resolvinglist = false
          // This is to resolve issue 626
          if (StartsWith(var, "objectexit")) {
            result = ResolveName(var, value, "exit")
          }
          if (result = null) {
            if (StartsWith(var, "object")) {
              if (GetBoolean(game.pov.currentcommandpattern, "allow_all")) {
                scope = FilterByAttribute(GetScope("object", "", "object"), "scenery", false)
                game.pov.currentcommandpendingobjectscope = ListExclude(scope, FilterByAttribute(scope, "not_all", true))
                game.pov.currentcommandpendingvariable = var
                ResolveNameList (value, "object")
                resolvinglist = true
              }
              else if (HasScript(game.pov.currentcommandpattern, "multipleobjects")) {
                game.pov.currentcommandpendingobjectlist = NewObjectList()
                game.pov.currentcommandpendingvariable = var
                do (game.pov.currentcommandpattern, "multipleobjects")
                ResolveNameList (value, "object")
                resolvinglist = true
              }
              else {
                result = ResolveName(var, value, "object")
              }
            }
            else if (StartsWith(var, "exit")) {
              result = ResolveName(var, value, "exit")
            }
            else if (StartsWith(var, "text")) {
              result = StringDictionaryItem(game.pov.currentcommandvarlist, var)
            }
            else {
              error ("Unhandled command variable '" + var + "' - command variable names must begin with 'object', 'exit' or 'text'")
            }
          }
          // at this point, ResolveName has returned - either an object name, unresolved, or pending
          if (result = null) {
            if ((not resolvinglist) and LengthOf(GetString(game.pov, "currentcommandpendingvariable")) = 0) {
              UnresolvedCommand (value, var)
            }
          }
          else {
            AddToResolvedNames (var, result)
          }
        }
        else {
          ResolveNextName
        }
      }
      else {
        resolvedall = true
      }
    }
    else if (queuetype = "null") {
      resolvedall = true
    }
    else {
      error ("Invalid queue type")
    }
    if (resolvedall) {
      // All the objects have been resolved, so now we can actually do the command
      // TO DO: game.lastobjects should be game.pov.lastobjects
      game.lastobjects = game.pov.currentcommandresolvedobjects
      if (not DictionaryContains(game.pov.currentcommandresolvedelements, "multiple")) {
        dictionary add (game.pov.currentcommandresolvedelements, "multiple", false)
      }
      if (not GetBoolean(game.pov.currentcommandpattern, "isundo")) {
        if (LengthOf(game.pov.currentcommand) > 0) {
          start transaction (game.pov.currentcommand)
        }
      }
      if (not GetBoolean(game.pov.currentcommandpattern, "isoops")) {
        // TO DO: game.unresolved* should be game.pov.unresolved*
        game.unresolvedcommand = null
        game.unresolvedcommandvarlist = null
        game.unresolvedcommandkey = null
      }
      if (DictionaryContains(game.pov.currentcommandresolvedelements, "object")) {
        game.text_processor_this = ObjectDictionaryItem(game.pov.currentcommandresolvedelements, "object")
      }
      else if (DictionaryContains(game.pov.currentcommandresolvedelements, "object1")) {
        game.text_processor_this = ObjectDictionaryItem(game.pov.currentcommandresolvedelements, "object1")
      }
      if (HasScript(game.pov.currentcommandpattern, "script")) {
        // This is the bit that actually runs the commands
        // do (game.pov.currentcommandpattern, "script", game.pov.currentcommandresolvedelements)
        PERFORM_COMMAND (game.pov.currentcommandpattern, "script", game.pov.currentcommandresolvedelements)
      }
      //
      // Setting game.runturnscripts to true to run turn scripts after ShowMenu , show menu, ask, or Ask.
      // This works in conjuction with FinishTurn, which has also been modified as of Quest 5.8.
      // - KV, 2018/05/25
      game.runturnscripts = true
      FinishTurn
      HandleNextCommandQueueItem
    }
  ]]></function>

  <function name="ResolveNameList" parameters="value, objtype" type="list">
    game.pov.currentcommandallbut = false
    game.pov.currentcommandpendingobjectlist = NewObjectList()
    game.pov.currentcommandpendingobjectlistunresolved = NewStringList()
    game.pov.currentcommandpendingobjecttype = objtype
    if (StartsWith(value,"all but")) {
      dLog ("[ResolveNameList] Found 'all but'!")
      value = Replace(value,"all but ","")
      game.pov.currentcommandallbut = true
    }
    value = Replace (value, ", " + Template("And") + " ", " " + Template("And") + " ")
    inputlist = Split(value, ",")
    foreach (inputbase, inputlist) {
      inputlist2 = Split(inputbase, " " + Template("And") + " ")
      foreach (input, inputlist2) {
        list add (game.pov.currentcommandpendingobjectlistunresolved, input)
      }
    }
    ResolveNextNameListItem
  </function>

  <function name="RunTurnScripts"><![CDATA[
    if (IsGameRunning()) {
      if (game.menucallback = null) {
        dLog ("[RunTurnScripts]...")
        // set hasacted for Undo bug
        game.hasacted = true
        foreach (turnscript, AllTurnScripts()) {
          if (GetBoolean(turnscript, "enabled")) {
            inscope = false
            if (turnscript.parent = game or turnscript.parent = null) {
              inscope = true
            }
            else {
              if (Contains(turnscript.parent, game.pov)) {
                inscope = true
              }
            }
            if (inscope) {
              if (HasAttribute (turnscript, "TICK")) {
                dLog ("[RunTurnScripts] " + turnscript.name + " has TICK: " + turnscript.TICK)
                if (not turnscript.TICK = 0) {
                  if (not turnscript.TICK > 1) {
                    dLog ("[RunTurnScripts] firing " + turnscript)
                    do (turnscript, "script")
                  }
                  turnscript.TICK = turnscript.TICK - 1
                  dLog ("[RunTurnScripts] " + turnscript.name + " new TICK: " + turnscript.TICK)
                }
              }
              else {
                dLog ("[RunTurnScripts] " + turnscript.name + " has no TICK and is enabled; firing.")
                do (turnscript, "script")
              }
            }
          }
        }
      }
    }
  ]]></function>

  <function name="HandleCommand" parameters="command, metadata"><![CDATA[
    handled = false
    if (game.menucallback <> null) {
      if (HandleMenuTextResponse(command)) {
        handled = true
      }
      else {
        if (game.menuallowcancel) {
          ClearMenu
        }
        else {
          handled = true
        }
      }
    }
    if (not handled) {
      // if (GetBoolean(game,"recording_steps")){
        // if (not HasAttribute(game,"steps_recorded")){
          // game.steps_recorded = NewStringList()
          // }
        // list add (game.steps_recorded,command)
        // }
      StartTurnOutputSection
      if (StartsWith (command, "*")) {
        game.suppressturnscripts = true
        msg ("")
        msg (SafeXML (command))
        msg ("Noted.")
        FinishTurn
      }
      else {
        if (Instr (command,"?") > 0 and (StartsWith(command,"what") or StartsWith(command,"where"))) {
          command = Replace(command,"?","") 
        }
        shownlink = false
        if (game.echocommand) {
          if (metadata <> null and game.enablehyperlinks and game.echohyperlinks) {
            foreach (key, metadata) {
              if (EndsWith(command, key)) {
                objectname = StringDictionaryItem(metadata, key)
                object = GetObject(objectname)
                if (object <> null) {
                  msg ("")
                  msg ("&gt; " + Left(command, LengthOf(command) - LengthOf(key)) + "{object:" + object.name + "}")
                  shownlink = true
                }
              }
            }
          }
          if (not shownlink) {
            msg ("")
            OutputTextRaw ("&gt; " + SafeXML(command))
          }
        }
        else {
          if (not GetBoolean(game, "notranscript") and GetBoolean(game, "savingtranscript")) {
            JS.writeToTranscript ("<span><br/>> " + SafeXML(command) + "<br/></span>")
          }
        }
        if (game.command_newline) {
          msg ("")
        }
        game.pov.commandmetadata = metadata
        if (game.multiplecommands) {
          if (Instr(command, " and ") > 0){
            //msg ("checking for ands...")
            ands = NewList()
            lexv = Split(command, " ")
            andi = 0
            foreach (wrd,lexv){
              if (wrd = "and"){
                list add (ands, andi)
                //msg ("found an and at index " + andi)
              }
              andi = andi + 1
            }
            foreach (ind, ands){
              if (ListCount (lexv) > ind - 1){
                nw = StringListItem (lexv, ind + 1)
                //msg ("the next word after and at " + ind + " is " + nw)
                typ = GET_PART_OF_SPEECH (nw)
                //msg ("...it is type " + typ)
                validexit = (not (typ and game.ps_direction) = 0) and not GetExitByName(GLOBAL.HERE, nw) = null
                //msg ("validexit? " + validexit)
                if (((not (typ and game.ps_verb) = 0) or validexit) and (typ and game.ps_object) = 0 and ((typ and game.ps_adjective) = 0 or validexit)) {
                  PUT (lexv, ind, "then")
                  //msg("replaced an and with then")
                }
              }
            }
            command = Join (lexv, " ")
          }
          command = Replace(command, " then ", ".")
          if (Trim(Replace(command,".","")) = ""){
            msg ("I beg your pardon?")
            RFATAL
            return (2)
          }
          commands = Split(command, ".")
          if (ListCount(commands) = 1) {
            game.pov.commandqueue = null
            HandleSingleCommand (Trim(command))
          }
          else {
            game.pov.commandqueue = commands
            HandleNextCommandQueueItem
          }
        }
        else {
          game.pov.commandqueue = null
          HandleSingleCommand (Trim(command))
        }
      }
    }
  ]]></function>

  <function name="ResolveNameFromList" parameters="variable, value, objtype, scope, secondaryscope" type="object"><![CDATA[
    value = Trim(LCase(value))
    fullmatches = NewObjectList()
    partialmatches = NewObjectList()
    foreach (obj, scope) {
      name = LCase(GetDisplayAlias(obj))
      CompareNames (name, value, obj, fullmatches, partialmatches)
      if (obj.alt <> null) {
        foreach (altname, obj.alt) {
          CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)
        }
      }
    }
    // allow referring to objects from the previous command by gender or article
    // if (objtype = "object" and game.lastobjects <> null) {
      // foreach (obj, game.lastobjects) {
        // CompareNames (LCase(obj.article), value, obj, fullmatches, partialmatches)
        // CompareNames (LCase(obj.gender), value, obj, fullmatches, partialmatches)
        // }
      // }
    // pronouns hack
    foreach (key, GLOBAL.CURRENT_PRONOUNS) {
      obj = ObjectDictionaryItem(GLOBAL.CURRENT_PRONOUNS,key)
      if (not obj = NOTHING) {
        if (LCase(key) = value) {
          if (not ListContains(ScopeVisible(),obj)) {
            msg ("(the " + obj.alias + ")")
          }
          else {
            CompareNames (LCase(key), value, obj, fullmatches, partialmatches)
          }
        }
      }
    }
    // Also check the secondary scope, but only if we have not found anything yet
    if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 0 and not secondaryscope = null) {
      foreach (obj, secondaryscope) {
        name = LCase(GetDisplayAlias(obj))
        CompareNames (name, value, obj, fullmatches, partialmatches)
        if (obj.alt <> null) {
          foreach (altname, obj.alt) {
            CompareNames (LCase(altname), value, obj, fullmatches, partialmatches)
          }
        }
      }
    }
    if (ListCount(fullmatches) = 1) {
      return (ListItem(fullmatches, 0))
    }
    else if (ListCount(fullmatches) = 0 and ListCount(partialmatches) = 1) {
      return (ListItem(partialmatches, 0))
    }
    else if (ListCount(fullmatches) + ListCount(partialmatches) = 0) {
      return (null)
    }
    else {
      // Added this line to resolve issue with new FinishTurn setup in 580
      game.disambiguating = true
      candidates = ListCompact(ListCombine(fullmatches, partialmatches))
      precandy = ListExclude(candidates, player)
      foreach (o, precandy) {
        if (HasAttribute (o, "GWIM")) {
          if (TypeOf(o.GWIM) = "object") {
            Log ("GWIM: " + o.name)
            game.disambiguating = false
            return (o.GWIM)
          }
          else if (TypeOf(o.GWIM) = "string") {
            gwim = Eval(o.GWIM + "()")
            if (gwim <> null) {
              Log ("GWIM: " + o.name)
              game.disambiguating = false
              return (gwim)
            }
          }
        }
        if (o.parent = GLOBAL_OBJECTS or o.parent = LOCAL_GLOBALS) {
          list remove (candidates, o)
        }
      }
      if (ListCount(candidates) = 1) {
        Log ("GWIM: " + o.name)
        game.disambiguating = false
        return (ListItem (candidates, 0))
      }
      else {
        candidates = precandy
      }
      if (LengthOf(variable) > 0) {
        // single object command, so after showing the menu, add the object to game.pov.currentcommandresolvedelements
        game.pov.currentcommandpendingvariable = variable
        ShowMenu (DynamicTemplate("DisambiguateMenu", value), candidates, true) {
          varname = game.pov.currentcommandpendingvariable
          game.pov.currentcommandpendingvariable = null
          if (result <> null) {
            AddToResolvedNames (varname, GetObject(result))
          }
        }
      }
      else {
        // multi-object command, so after showing the menu, add the object to the list
        game.pov.currentcommandmultiobjectpending = true
        ShowMenu (DynamicTemplate("DisambiguateMenu", value), candidates, true) {
          if (result <> null) {
            list add (game.pov.currentcommandpendingobjectlist, GetObject(result))
            ResolveNextNameListItem
          }
        }
      }
      return (null)
    }
  ]]></function>

  <function name="InitInterface"><![CDATA[
    // Added by KV for transcript
    // Use JSSafe to remove any offensive characters!  - KV   May 27, 2018
    jsgamename = JSSafe(game.gamename)
    JS.eval ("var gameName = '"+jsgamename+"';var transcriptName = gameName;")
    if (GetBoolean(game,"savetranscript")) {
      JS.eval ("var savingTranscript = true;")
      JS.replaceTranscriptString (game.transcriptstring)
    }
    // End of addition by KV for transcript
    if (game.setcustomwidth) {
      JS.setGameWidth (game.customwidth)
    }
    if (game.setcustompadding) {
      JS.setGamePadding (game.custompaddingtop, game.custompaddingbottom, game.custompaddingleft, game.custompaddingright)
    }
    if (game.externalstylesheets <> null) {
      foreach (stylesheet, game.externalstylesheets) {
        JS.addExternalStylesheet (stylesheet)
      }
    }
    if (game.setbackgroundopacity) {
      SetBackgroundOpacity (game.backgroundopacity)
    }
    SetBackgroundColour (game.defaultbackground)
    SetForegroundColour (game.defaultforeground)
    SetLinkForegroundColour (game.defaultlinkforeground)
    if (LengthOf(game.backgroundimage) > 0) {
      SetBackgroundImage (game.backgroundimage)
    }
    JS.setCompassDirections (Join(game.compassdirections, ";"))
    JS.setInterfaceString ("InventoryLabel", "Inventory")
    JS.setInterfaceString ("StatusLabel", "Status")
    JS.setInterfaceString ("PlacesObjectsLabel", "Places and Objects")
    JS.setInterfaceString ("CompassLabel", "Compass")
    JS.setInterfaceString ("InButtonLabel", "in")
    JS.setInterfaceString ("OutButtonLabel", "out")
    JS.setInterfaceString ("EmptyListLabel", "(empty)")
    JS.setInterfaceString ("NothingSelectedLabel", "(nothing selected)")
    JS.setInterfaceString ("TypeHereLabel", "Type here...")
    JS.setInterfaceString ("ContinueLabel", "Continue...")
    JS.SetMenuBackground (game.menubackground)
    JS.SetMenuForeground (game.menuforeground)
    JS.SetMenuHoverBackground (game.menuhoverbackground)
    JS.SetMenuHoverForeground (game.menuhoverforeground)
    JS.SetMenuFontName (game.menufont)
    JS.SetMenuFontSize (game.menufontsize + "pt")
    if (not game.underlinehyperlinks) {
      JS.TurnOffHyperlinksUnderline ()
    }
    ResetCommandBarFormat
    if (game.showcommandbar) {
      JS.uiShow ("#txtCommandDiv")
    }
    else {
      JS.uiHide ("#txtCommandDiv")
    }
    if (HasString(game, "panelcontents")) {
      SetFramePicture (game.panelcontents)
    }
    if (game.gridmap) {
      JS.ShowGrid (game.mapsize)
      Grid_SetScale (game.mapscale)
      if (game.pov <> null) {
        if (game.pov.parent <> null) {
          Grid_Redraw
          Grid_DrawPlayerInRoom (game.pov.parent)
        }
      }
    }
    // Added by the Pixie
    // Note that panesVisible in playercore.js must be updated too
    // This line will get the save confirmation to appear in the right font and colour
    JS.setCss ("body", "color:" + game.defaultforeground + ";font-family:" + game.defaultfont + ";font-size:" + game.defaultfontsize + "pt;")
    // various new options
    if (HasString(game, "bordercolour")) {
      JS.setCss ("#gameBorder", "border-left:1px solid " + game.bordercolour + ";border-right:1px solid " + game.bordercolour)
    }
    if (not game.classiclocation) {
      JS.setCss ("#status", "background-image:none")
      JS.setCss ("#qv-status", "background-image:none")
      if (HasString(game, "customlocationcolour")) {
        JS.setCss ("#status", "background-color:" + game.customlocationcolour)
        JS.setCss ("#qv-status", "background-color:" + game.customlocationcolour)
      }
      else {
        JS.setCss ("#status", "background:transparent")
        JS.setCss ("#qv-status", "background:transparent")
      }
      if (HasString(game, "customlocationtextcolour")) {
        JS.setCss ("#status", "color:" + game.customlocationtextcolour)
        JS.setCss ("#qv-status", "color:" + game.customlocationtextcolour)
      }
      if (HasString(game, "customlocationbordercolour")) {
        JS.setCss ("#status", "border:1px solid " + game.customlocationbordercolour)
        JS.setCss ("#qv-status", "border:1px solid " + game.customlocationbordercolour)
      }
      else {
        JS.setCss ("#status", "border:none")
        JS.setCss ("#qv-status", "border:none")
      }
      if (HasString(game, "locationbarimage")) {
        if (not Trim(game.locationbarimage) = "") {
          url = GetFileURL(game.locationbarimage)
          JS.eval ("$('.ui-widget-header').css('background-image','url(" + url + ")');")
        }
      }
    }
    // request (Show, "Location")
    if (game.showlocation) {
      JS.uiShow ("#location")
      JS.setCss ("#status", "display:block")
      JS.setCss ("#qv-status", "display:block")
    }
    else {
      JS.setCss ("#status", "display:none")
      JS.setCss ("#qv-status", "display:none")
    }
    if (HasString(game, "marginscolour")) {
      JS.setCss ("body", "background-color:" + game.marginscolour)
    }
    if (game.turnoffsavebutton) {
      JS.setCss ("#controlButtons", "display:none")
    }
    if (game.turnoffcompass) {
      JS.setCss ("#compassLabel", "display:none;")
      JS.setCss ("#compassAccordion", "display:none;")
    }
    if (game.turnoffinventory) {
      JS.setCss ("#inventoryLabel", "display:none")
      JS.setCss ("#inventoryAccordion", "display:none")
    }
    if (game.turnoffplacesandobjects) {
      JS.setCss ("#placesObjectsLabel", "display:none")
      JS.setCss ("#placesObjectsAccordion", "display:none")
    }
    if (game.statusandcompassattop) {
      JS.eval ("$('#commandPane').insertBefore('#inventoryLabel')")
      JS.eval ("$('#customStatusPane').insertBefore('#inventoryLabel')")
      JS.eval ("$('#statusVarsLabel').insertBefore('#inventoryLabel')")
      JS.eval ("$('#statusVarsAccordion').insertBefore('#inventoryLabel')")
      JS.eval ("$('#compassLabel').insertBefore('#inventoryLabel')")
      JS.eval ("$('#compassAccordion').insertBefore('#inventoryLabel')")
    }
    if (game.showpanes and game.commandpane) {
      JS.setCss ("#commandPane", "display:block")
    }
    if (game.showpanes and game.customstatuspane) {
      JS.setCss ("#customStatusPane", "display:block")
    }
    if (game.colourblend) {
      JS.colourBlend (game.colourblendtop, game.colourblendbottom)
    }
    if (game.borderlesscursor) {
      JS.addScript ("<style>#txtCommand { outline:none; border:none; margin:0; padding:0; width:100px; background-color:transparent;}</style>")
      JS.setCss ("#txtCommandDiv", "color:" + game.defaultforeground)
      JS.eval ("$('#txtCommandPrompt').html('" + game.commandcursor + "')")
    }
    else if (game.shadowbox) {
      JS.addScript ("<style>#txtCommand { outline:none; border:none; margin:2px; padding:7px; width:100 px;box-shadow: 0px 0px 15px 5px #888;}</style>")
    }
    if (game.panestheme = "Midnight") {
      JS.setPanes ("white", "midnightblue", "midnightblue", "skyblue")
    }
    if (game.panestheme = "Nature") {
      JS.setPanes ("#A1C935", "#254117", "#306754", "#A1C935", "green")
    }
    if (game.panestheme = "Parchment") {
      JS.setPanes ("#493D26", "#FAEBD7", "#FAEBD7", "#493D26", "#C88141")
    }
    if (game.panestheme = "Vanilla") {
      JS.setPanes ("black", "white")
    }
    if (game.panestheme = "Black") {
      JS.setPanes ("orange", "black", "black", "orange")
    }
    if (game.panestheme = "Blood") {
      JS.setPanes ("orange", "#800000", "#800000", "orange", "yellow")
    }
    if (game.panestheme = "Tranquil") {
      JS.setPanes ("midnightblue", "skyblue", "white", "midnightblue", "blue")
    }
    if (game.respondtogridclicks) {
      JS.respondToGridClicks (true)
    }
    //
    // -----------------------------------------------------------------------
    // This is in the original, but must come last
    if (not game.showborder) {
      JS.hideBorder ()
    }
    if (game.showpanes) {
      JS.panesVisible (true)
    }
    else {
      JS.panesVisible (false)
    }
    JS.getDivCount ()
    if (not game.pov = null) {
      JS.updateLocation (CapFirst(GetDisplayName(game.pov.parent)) + "<span class=\"score-moves\" style=\"float:right;margin-right:1%;\">Score: " + GLOBAL.SCORE + "&emsp;Moves: " + GLOBAL.MOVES + "&emsp;</span>")
    }
    InitUserInterface
    if (HasScript(game, "inituserinterface")) {
      do (game, "inituserinterface")
    }
  ]]></function>

  <function name="ShowRoomDescription">
    // V_FIRST_LOOK
  </function>

  <function name="OutputTextRaw" parameters="text"><![CDATA[
    if (GetBoolean (game, "OUTPUT_OFF")) {
      dLog ("[OutputTextRaw] game.OUTPUT_OFF is true; not printing")
      Log ("[OutputTextRaw]: " + text)
    }
    else {
      format = GetCurrentTextFormat("")
      JS.addText ("<span style=\"" + format + "\">" + text + "</span><br/>")
      if (GetString(game, "commandbarformat") <> format) {
        ResetCommandBarFormat
      }
      RequestSpeak (text)
    }
  ]]></function>

  <function name="OutputTextRawNoBr" parameters="text"><![CDATA[
    if (GetBoolean (game, "OUTPUT_OFF")) {
      Log ("[OutputText] game.OUTPUT_OFF is true; not printing")
      Log ("[OutputText]: " + text)
    }
    else {
      JS.addText ("<span style=\"" + GetCurrentTextFormat("") + "\">" + text + "</span>")
      RequestSpeak (text)
    }
  ]]></function>
  
  <function name="CompareNames" parameters="name, value, obj, fullmatches, partialmatches"><![CDATA[
    namearr = Split(name, " ")
    nlen = ListCount (namearr)
    valuearr = Split(value, " ")
    vlen = ListCount (valuearr)
    name = ""
    value = ""
    foreach (wrd, namearr) {
      wrd = Left (wrd, 6)
      name = name + " " + wrd
    }
    foreach (wrd, valuearr) {
      wrd = Left (wrd, 6)
      value = value + " " + wrd
    }
    name = Trim(name)
    //msg("name: " + name)
    value = Trim(value)
    //msg("value: " + value)
    if (name = value) {
      if (not ListContains(fullmatches, obj)) {
        list add (fullmatches, obj)
      }
    }
    // check if input matches the start of any word in the name
    else {
      if (Instr(name, value) = 1 or Instr(name, " " + value) > 0) {
        narr = Split(name, " ")
        varr = Split(value, " ")
        matches = 0
        foreach (wrd,varr){
          if (ListContains(narr, wrd)){
            matches = matches + 1
          }
        }
        if (matches = ListCount (varr)) {
          if (not ListContains(partialmatches, obj)) {
            //msg("adding " + obj)
            list add (partialmatches, obj)
          }
        }
      }
    }
  ]]></function>

</library>